{"version":3,"sources":["../src/react/context/chipi-provider.tsx","../src/core/lib/encryption.ts","../src/core/create-wallet.ts","../src/react/hooks/use-create-wallet.ts","../src/react/hooks/use-sign.ts"],"names":["createContext","jsx","useContext","CryptoJS","RpcProvider","stark","ec","CairoCustomEnum","CairoOption","CairoOptionVariant","CallData","hash","Account","fetchBuildTypedData","BASE_URL","num","fetchExecuteTransaction","useMutation"],"mappings":"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","file":"chunk-E2UQ7DG4.js","sourcesContent":["import { createContext, useContext } from 'react';\nimport type { ChipiSDKConfig } from '../../core/types';\n\ninterface ChipiContextValue {\n  config: ChipiSDKConfig;\n}\n\nconst ChipiContext = createContext<ChipiContextValue | null>(null);\n\nexport function ChipiProvider({ \n  children, \n  config \n}: { \n  children: React.ReactNode;\n  config: ChipiSDKConfig;\n}) {\n  return (\n    <ChipiContext.Provider value={{ config }}>\n      {children}\n    </ChipiContext.Provider>\n  );\n}\n\nexport function useChipiContext() {\n  const context = useContext(ChipiContext);\n  if (!context) {\n    throw new Error('useChipiContext must be used within a ChipiProvider');\n  }\n  return context;\n}","import CryptoJS from \"crypto-js\";\n\nexport const encryptPrivateKey = (\n  privateKey: string,\n  password: string,\n): string => {\n  if (!privateKey || !password) {\n    throw new Error(\"Private key and password are required\");\n  }\n\n  return CryptoJS.AES.encrypt(privateKey, password).toString();\n};\n\nexport const decryptPrivateKey = (\n  encryptedPrivateKey: string,\n  password: string,\n): string | null => {\n  if (!encryptedPrivateKey || !password) {\n    console.error(\"Encrypted private key and password are required\");\n    return null;\n  }\n\n  try {\n    const bytes = CryptoJS.AES.decrypt(encryptedPrivateKey, password);\n    const decrypted = bytes.toString(CryptoJS.enc.Utf8);\n\n    // Check if the decrypted string is empty\n    if (!decrypted) {\n      return null;\n    }\n\n    return decrypted;\n  } catch (error) {\n    console.error(\"Decryption failed:\", error);\n    return null;\n  }\n};\n","import type { DeploymentData, GaslessOptions } from \"@avnu/gasless-sdk\";\nimport {\n  BASE_URL,\n  fetchBuildTypedData,\n  fetchExecuteTransaction,\n} from \"@avnu/gasless-sdk\";\nimport type { Call } from \"starknet\";\nimport {\n  Account,\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CallData,\n  ec,\n  hash,\n  num,\n  RpcProvider,\n  stark,\n} from \"starknet\";\nimport { encryptPrivateKey } from \"./lib/encryption\";\n\nexport interface CreateWalletParams {\n  pin: string;\n  rpcUrl: string;\n  options: GaslessOptions;\n  argentClassHash: string;\n  contractAddress: string;\n  contractEntryPoint: string;\n}\n\nexport const createArgentWallet = async (params: CreateWalletParams) => {\n  try {\n    const provider = new RpcProvider({\n      nodeUrl: params.rpcUrl,\n    });\n  \n    // Generating the private key with Stark Curve\n    const privateKeyAX = stark.randomAddress();\n    const starkKeyPubAX = ec.starkCurve.getStarkKey(privateKeyAX);\n  \n    // Using Argent X Account v0.4.0 class hash\n    // POR REVISAR: CLASSHASH ES EL MISMO EN MAINNET?\n    const accountClassHash = params.argentClassHash as string || \"0x036078334509b514626504edc9fb252328d1a240e4e948bef8d0c08dff45927f\" as string;\n  \n    // Calculate future address of the ArgentX account\n    const axSigner = new CairoCustomEnum({ Starknet: { pubkey: starkKeyPubAX } });\n    // Set the dApp Guardian address\n    const axGuardian = new CairoOption<unknown>(CairoOptionVariant.None);\n  \n    const AXConstructorCallData = CallData.compile({\n      owner: axSigner,\n      guardian: axGuardian,\n    });\n  \n    const contractAddress = hash.calculateContractAddressFromHash(\n      starkKeyPubAX,\n      accountClassHash,\n      AXConstructorCallData,\n      0,\n    );\n  \n    // Initiating Account\n    const account = new Account(provider, contractAddress, privateKeyAX);\n    console.log(\"Account \", { ...account });\n\n    const initialValue: Call[] = [\n        {\n          contractAddress: params.contractAddress || \"0x05039371eb9f5725bb3012934b8821ff3eb3b48cbdee3a29f798c17e9a641544\",\n          entrypoint: params.contractEntryPoint || \"get_counter\",\n          calldata: [contractAddress],\n        },\n      ];\n    \n      const typeData = await fetchBuildTypedData(\n        contractAddress,\n        initialValue,\n        undefined,\n        undefined,\n        {baseUrl: BASE_URL, apiKey: params.options.apiKey},\n        accountClassHash,\n      );\n    \n      const userSignature = await account.signMessage(typeData);\n    \n      const deploymentData: DeploymentData = {\n        class_hash: accountClassHash,\n        salt: starkKeyPubAX,\n        unique: `${num.toHex(0)}`,\n        calldata: AXConstructorCallData.map((value) => num.toHex(value)),\n      };\n    \n      const executeTransaction = await fetchExecuteTransaction(\n        contractAddress,\n        JSON.stringify(typeData),\n        userSignature,\n        params.options,\n        deploymentData,\n      );\n\n      const encryptedPrivateKey = encryptPrivateKey(privateKeyAX, params.pin);\n      console.log(\"Encrypted private key: \", encryptedPrivateKey);\n    \n      // Now lets save the wallet in clerk public metadata\n      /* await saveWallet({\n        contractAddress: contractAddress as `0x${string}`,\n        encryptedPrivateKey: encryptPrivateKey(privateKeyAX, params.pin),\n      });\n      console.log(\n        `Wallet created successfully with txHash: ${executeTransaction.transactionHash}`,\n      ); */\n    \n      // TODO: Guardar la wallet en dashboard\n      console.log(\"Wallet created successfully with txHash: \", executeTransaction.transactionHash);\n      console.log(\"Account address: \", contractAddress);\n      return { success: true, accountAddress: contractAddress, txHash: executeTransaction.transactionHash };\n  } catch (error: unknown) {\n    console.error(\"Error detallado:\", error);\n    \n    if (error instanceof Error && error.message.includes('SSL')) {\n      throw new Error(\"Error de conexión SSL. Intenta usando NODE_TLS_REJECT_UNAUTHORIZED=0 o verifica la URL del RPC\");\n    }\n    \n    throw new Error(`Error creating Argent wallet: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}","import { useMutation } from '@tanstack/react-query';\nimport { createArgentWallet } from '../../core/create-wallet';\nimport { WalletData } from '../../core/types';\n\ninterface UseCreateWalletOptions {\n  onSuccess?: (wallet: WalletData) => void;\n  onError?: (error: Error) => void;\n}\n\nexport function useCreateWallet(options?: UseCreateWalletOptions) {\n  const mutation = useMutation({\n    mutationFn: async (pin: string) => {\n      const wallet = await createArgentWallet({\n        pin,\n        // ... other params from SDK context\n        rpcUrl: \"https://rpc.ankr.com/starknet\",\n        argentClassHash: \"0x07a5267d00000000000000000000000000000000000000000000000000000000\",\n        contractAddress: \"0x07a5267d00000000000000000000000000000000000000000000000000000000\",\n        contractEntryPoint: \"get_counter\",\n        options: {\n          baseUrl: \"https://paymaster.avnu.fi\",\n          apiKey: \"your_api_key\",\n          apiPublicKey: \"your_api_public_key\",\n        }\n      });\n\n    return {\n        publicKey: wallet.accountAddress, // assuming accountAddress can serve as publicKey\n        encryptedPrivateKey: '', // you'll need to get this from somewhere\n        accountAddress: wallet.accountAddress,\n        txHash: wallet.txHash,\n        success: wallet.success\n      };\n    },\n    onSuccess: options?.onSuccess,\n    onError: options?.onError,\n  });\n\n  return {\n    createWallet: mutation.mutate,\n    isCreating: mutation.isPending,\n    error: mutation.error,\n    wallet: mutation.data,\n  };\n}","// import { useMutation } from '@tanstack/react-query';\n// import { executePaymasterTransaction } from '../../core/send-transaction-with-paymaster';\n// import type { SignParams,WalletData } from '../../core/types';\n\n// interface UseSignOptions {\n//   wallet: WalletData;\n//   onSuccess?: (txHash: string) => void;\n//   onError?: (error: Error) => void;\n// }\n\n// export function useSign({ wallet, ...options }: UseSignOptions) {\n//   const mutation = useMutation({\n//     mutationFn: async (params: SignParams) => {\n//       return executePaymasterTransaction({\n//         ...params,\n//         wallet,\n//         // ... other params from SDK context\n//       });\n//     },\n//     onSuccess: options?.onSuccess,\n//     onError: options?.onError,\n//   });\n\n//   return {\n//     sign: mutation.mutate,\n//     isSigning: mutation.isPending,\n//     error: mutation.error,\n//     lastTxHash: mutation.data,\n//   };\n// }\n\n\nexport function useSign(){\n  return {\n    sign: () => {\n      return \"sign 3\";\n    }\n  }\n}"]}